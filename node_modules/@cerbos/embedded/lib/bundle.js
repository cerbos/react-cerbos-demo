"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.download = exports.Bundle = void 0;
const core_1 = require("@cerbos/core");
const request_1 = require("./protobuf/cerbos/request/v1/request");
const response_1 = require("./protobuf/cerbos/response/v1/response");
const slice_1 = require("./slice");
const services = {
    admin: {
        addOrUpdatePolicy: undefined,
        addOrUpdateSchema: undefined,
        deleteSchema: undefined,
        disablePolicy: undefined,
        enablePolicy: undefined,
        getPolicy: undefined,
        getSchema: undefined,
        listPolicies: undefined,
        listSchemas: undefined,
        reloadStore: undefined,
    },
    cerbos: {
        checkResources: {
            method: "check",
            transformRequest: async (request, decodeJWTPayload) => {
                const transformedRequest = request_1.CheckResourcesRequest.toJSON(request);
                if (transformedRequest.auxData?.jwt) {
                    const jwt = transformedRequest.auxData.jwt;
                    if (!jwt.keySetId) {
                        delete jwt.keySetId;
                    }
                    transformedRequest.auxData.jwt =
                        await decodeJWTPayload(jwt);
                }
                return transformedRequest;
            },
            transformResponse: (response) => response_1.CheckResourcesResponse.fromJSON(response),
        },
        planResources: undefined,
        serverInfo: undefined,
    },
};
class Bundle {
    etag;
    exports;
    decodeJWTPayload;
    static async from(source, { decodeJWTPayload = cannotDecodeJWTPayload, globals, now = Date.now, }) {
        if (typeof source === "string" || source instanceof URL) {
            source = await download(source);
        }
        else {
            source = await source;
        }
        const etag = source instanceof Response
            ? source.headers.get("ETag") ?? undefined
            : undefined;
        const exports = await instantiate(source, {
            env: {
                now: () => secondsSinceUnixEpoch(now()),
            },
        });
        if (globals) {
            const globalsSlice = slice_1.Slice.ofJSON(exports, globals);
            try {
                exports.set_globals(globalsSlice.offset, globalsSlice.length);
            }
            finally {
                globalsSlice.deallocate();
            }
        }
        return new Bundle(etag, exports, decodeJWTPayload);
    }
    _metadata;
    constructor(etag, exports, decodeJWTPayload) {
        this.etag = etag;
        this.exports = exports;
        this.decodeJWTPayload = decodeJWTPayload;
    }
    get metadata() {
        if (!this._metadata) {
            const { version, buildTimestamp, policies } = JSON.parse(slice_1.Slice.from(this.exports, this.exports.metadata()).text());
            this._metadata = {
                commit: version,
                builtAt: new Date(buildTimestamp * 1000),
                policies,
            };
        }
        return this._metadata;
    }
    async perform(service, rpc, request) {
        const implementation = services[service][rpc]; // https://github.com/microsoft/TypeScript/issues/30581;
        if (!implementation) {
            throw new core_1.NotOK(core_1.Status.UNIMPLEMENTED, `${rpc} is not implemented in embedded policy decision points`);
        }
        const { method, transformRequest, transformResponse } = implementation;
        const requestSlice = slice_1.Slice.ofJSON(this.exports, await transformRequest(request, this.decodeJWTPayload));
        let responseSlice;
        try {
            responseSlice = this.call(method, requestSlice);
        }
        finally {
            requestSlice.deallocate();
        }
        let responseText;
        try {
            responseText = responseSlice.text();
        }
        finally {
            responseSlice.deallocate();
        }
        try {
            return transformResponse(JSON.parse(responseText));
        }
        catch (_) {
            throw core_1.NotOK.fromJSON(responseText);
        }
    }
    call(method, { offset, length }) {
        return slice_1.Slice.from(this.exports, this.exports[method](offset, length));
    }
}
exports.Bundle = Bundle;
function cannotDecodeJWTPayload() {
    throw new Error("To decode JWTs from auxiliary data, you must provide a `decodeJWTPayload` function");
}
function secondsSinceUnixEpoch(date) {
    const millisecondsSinceUnixEpoch = date instanceof Date ? date.getTime() : date;
    return BigInt(Math.floor(millisecondsSinceUnixEpoch / 1000));
}
async function download(url, request) {
    try {
        return await fetch(url, request);
    }
    catch (error) {
        const message = `Failed to download from ${url.toString()}`;
        throw new Error(error instanceof Error ? `${message}: ${error.message}` : message, { cause: error });
    }
}
exports.download = download;
async function instantiate(source, imports) {
    if (source instanceof Response) {
        return await instantiateStreaming(source, imports);
    }
    return instantiated(await WebAssembly.instantiate(source, imports));
}
async function instantiateStreaming(response, imports) {
    if (!response.ok) {
        throw new Error(`Failed to download from ${response.url}: HTTP ${response.status}`);
    }
    return instantiated(await WebAssembly.instantiateStreaming(response, imports));
}
function instantiated({ instance: { exports }, }) {
    return exports;
}
//# sourceMappingURL=bundle.js.map